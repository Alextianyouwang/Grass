#pragma kernel Vote
#pragma kernel Scan
#pragma kernel Compact
#pragma kernel ClearArgs


struct Args
{
    uint meshVertCount;
    uint numOfInstance;
    uint meshIndexStart;
    uint meshBaseVertex;
    uint reserved;
};

struct SpawnData
{
    float3 positionWS;
    float hash;
    float4 clumpInfo;
    float4 postureData;
};

StructuredBuffer<SpawnData> _SpawnBuffer;
RWStructuredBuffer<uint> _VoteBuffer;
RWStructuredBuffer<uint> _ScanBuffer;
RWStructuredBuffer<SpawnData> _CompactBuffer;
RWStructuredBuffer<Args> _ArgsBuffer;


uint _InstanceCount;
float4x4 _Camera_VP;

#define WRAP_SIZE 32
groupshared int scan[WRAP_SIZE + WRAP_SIZE/2];

[numthreads(32, 1, 1)]
void Vote (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _InstanceCount)
        return;
    
    float3 pos = _SpawnBuffer[(int)id.x].positionWS;
    
    float4 posCS = mul(_Camera_VP, float4(pos,1));
    float3 posNDS = posCS.xyz / posCS.w;
    posNDS.z = -posCS.w;
   

    
    bool isInView = (posNDS.x < -1.1 || posNDS.x > 1.1 || posNDS.z  < -0.1) ? 0 : 1;
    _VoteBuffer[id.x] = isInView;
    

}

[numthreads(WRAP_SIZE, 1, 1)]
void Scan(uint3 id : SV_DispatchThreadID)
{
    int x = _VoteBuffer[id.x];
    int init = id.x + WRAP_SIZE / 2;
    scan[init] = x;
    int sum = x;

    [unroll]
    for (int i = 0; i < 5; i++)
    {
        GroupMemoryBarrierWithGroupSync();
        uint offset = 1 << i;
        sum += scan[init - offset];
        scan[init] = sum;
    }
    _ScanBuffer[id.x] = sum - x;


}
[numthreads(WRAP_SIZE, 1, 1)]
void Compact(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= _InstanceCount)
        return;
    
    if (_VoteBuffer[id.x] == 1)
    {
        InterlockedAdd(_ArgsBuffer[0].numOfInstance, 1);
        _CompactBuffer[_ScanBuffer[id.x]] = _SpawnBuffer[id.x];
    }

}
[numthreads(1, 1, 1)]
void ClearArgs(uint3 id : SV_DispatchThreadID)
{
    _ArgsBuffer[0].numOfInstance = 0;
}


